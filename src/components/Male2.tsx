/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.4 -t public/avatar/male2.glb
*/

import * as THREE from 'three'
import { Vector3, Euler, Quaternion } from 'three'
import React, { useEffect, useMemo, useRef } from 'react'
import { useGLTF, useAnimations } from '@react-three/drei'
import { Vec3 } from 'cannon-es'
import { GLTF } from 'three-stdlib'
import { useFrame, useThree } from '@react-three/fiber'
import { useCompoundBody, useContactMaterial } from '@react-three/cannon'

type GLTFResult = GLTF & {
  nodes: {
    Wolf3D_Avatar: THREE.SkinnedMesh
    Hips: THREE.Bone
  }
  materials: {
    Wolf3D_Avatar: THREE.MeshStandardMaterial
  }
}

type ActionName =
  'Armature.001|F_Standing_Idle_001|F_Standing_Idle_001:BaseAnimat'
type GLTFActions = Record<ActionName, THREE.AnimationAction>

export function useKeyboard() {
  const keyMap: any = useRef({})

  useEffect(() => {
    const onDocumentKey = (e: any) => {
      keyMap.current[e.code] = e.type === 'keydown'
    }
    document.addEventListener('keydown', onDocumentKey)
    document.addEventListener('keyup', onDocumentKey)
    return () => {
      document.removeEventListener('keydown', onDocumentKey)
      document.removeEventListener('keyup', onDocumentKey)
    }
  })

  return keyMap.current
}

export function useFollowCam() {
  const { scene, camera } = useThree()

  const pivot = useMemo(() => new THREE.Object3D(), [])
  const followCam = useMemo(() => {
    const o = new THREE.Object3D()
    o.position.set(0, 1, 1.5)
    return o
  }, [])

  const onDocumentMouseMove = (e) => {
    if (document.pointerLockElement) {
      pivot.rotation.y -= e.movementX * 0.002
      const v = followCam.rotation.x - e.movementY * 0.002
      if (v >= -1.0 && v <= 0.4) {
        followCam.rotation.x = v
        followCam.position.y = -v * followCam.position.z + 1
      }
    }
    return false
  }

  const onDocumentMouseWheel = (e) => {
    if (document.pointerLockElement) {
      const v = followCam.position.z + e.deltaY * 0.002
      if (v >= 0.5 && v <= 4) {
        followCam.position.z = v
      }
    }
    return false
  }

  useEffect(() => {
    camera.position.set(0, 0, 0)
    followCam.add(camera)
    pivot.add(followCam)
    scene.add(pivot)
    //console.log('attach followCam listeners')
    document.addEventListener('mousemove', onDocumentMouseMove)
    document.addEventListener('mousewheel', onDocumentMouseWheel)
    return () => {
      //console.log('remove followCam listeners')
      document.removeEventListener('mousemove', onDocumentMouseMove)
      document.removeEventListener('mousewheel', onDocumentMouseWheel)
    }
  })

  return { pivot }
}

export function Male2(props: JSX.IntrinsicElements['group']) {
  const group = useRef<THREE.Group>(null)
  const outer = useRef<THREE.Group>(null)
  const { nodes, materials, animations } = useGLTF(
    '/avatar/male2.glb'
  ) as GLTFResult
  // const { actions } = useAnimations<THREE.AnimationClip>(animations, group)

  // useEffect(() => {
  //   actions['Armature.001|F_Standing_Idle_001|F_Standing_Idle_001:BaseAnimat']
  //     ?.reset()
  //     .fadeIn(0.5)
  //     .play()
  // }, [actions])

  const position: [number, number, number] = [0, 0, 0]
  useContactMaterial('ground', 'slippery', {
    friction: 0,
    restitution: 0.01,
    contactEquationStiffness: 1e8,
    contactEquationRelaxation: 3,
  })

  const [ref, body] = useCompoundBody(
    () => ({
      mass: 1,
      shapes: [
        { args: [0.25], position: [0, 0.25, 0], type: 'Sphere' },
        { args: [0.25], position: [0, 0.75, 0], type: 'Sphere' },
        { args: [0.25], position: [0, 1.25, 0], type: 'Sphere' },
      ],
      onCollide: (e) => {
        if (e.contact.bi.id !== e.body.id) {
          contactNormal.set(...e.contact.ni)
        }
        if (contactNormal.dot(down) > 0.5) {
          if (inJumpAction.current) {
            inJumpAction.current = false
          }
        }
      },
      material: 'slippery',
      linearDamping: 0,
      position: position,
    }),
    useRef()
  )

  const playerGrounded = useRef(true)
  const inJumpAction = useRef(false)
  const velocity = useMemo(() => new Vector3(), [])
  const inputVelocity = useMemo(() => new Vector3(), [])
  const euler = useMemo(() => new Euler(), [])
  const quat = useMemo(() => new Quaternion(), [])
  const targetQuaternion = useMemo(() => new Quaternion(), [])
  const worldPosition = useMemo(() => new Vector3(), [])
  const raycasterOffset = useMemo(() => new Vector3(), [])
  const contactNormal = useMemo(() => new Vec3(0, 0, 0), [])
  const down = useMemo(() => new Vec3(0, -1, 0), [])
  const rotationMatrix = useMemo(() => new THREE.Matrix4(), [])
  const prevActiveAction = useRef(0) // 0:idle, 1:walking, 2:jumping
  const mixer = useMemo(() => new THREE.AnimationMixer(group.current!), [])
  const keyboard = useKeyboard()
  const actions: any = {}
  const { pivot } = useFollowCam()

  useFrame(({ raycaster }, delta) => {
    let activeAction = 0 // 0:idle, 1:walking, 2:jumping
    if (!ref.current || !group.current) return

    body.angularFactor.set(0, 0, 0)

    ref.current.getWorldPosition(worldPosition)

    playerGrounded.current = false
    raycasterOffset.copy(worldPosition)
    raycasterOffset.y += 0.01

    const distance = worldPosition.distanceTo(group.current.position)

    rotationMatrix.lookAt(
      worldPosition,
      group.current.position,
      group.current.up
    )
    targetQuaternion.setFromRotationMatrix(rotationMatrix)
    if (
      distance > 0.0001 &&
      !group.current.quaternion.equals(targetQuaternion)
    ) {
      targetQuaternion.z = 0
      targetQuaternion.x = 0
      targetQuaternion.normalize()
      group.current.quaternion.rotateTowards(targetQuaternion, delta * 20)
    }
    if (document.pointerLockElement) {
      inputVelocity.set(0, 0, 0)
      if (playerGrounded.current) {
        if (keyboard['KeyW']) {
          activeAction = 1
          inputVelocity.z = -10 * delta
        }
        if (keyboard['KeyS']) {
          activeAction = 1
          inputVelocity.z = 10 * delta
        }
        if (keyboard['KeyA']) {
          activeAction = 1
          inputVelocity.x = -10 * delta
        }
        if (keyboard['KeyD']) {
          activeAction = 1
          inputVelocity.x = 10 * delta
        }
      }
      inputVelocity.setLength(0.7) // clamps walking speed

      if (activeAction !== prevActiveAction.current) {
        //console.log('active action changed')
        if (prevActiveAction.current !== 1 && activeAction === 1) {
          //console.log('idle --> walking')
          actions['idle'].fadeOut(0.1)
          actions['walk'].reset().fadeIn(0.1).play()
        }
        if (prevActiveAction.current !== 0 && activeAction === 0) {
          //console.log('walking --> idle')
          actions['walk'].fadeOut(0.1)
          actions['idle'].reset().fadeIn(0.1).play()
        }
        prevActiveAction.current = activeAction
      }

      if (keyboard['Space']) {
        if (playerGrounded.current && !inJumpAction.current) {
          console.log('jump')
          activeAction = 2
          inJumpAction.current = true
          actions['walk'].fadeOut(0.1)
          actions['idle'].fadeOut(0.1)
          actions['jump'].reset().fadeIn(0.1).play()
          inputVelocity.y = 6
        }
      }

      euler.y = pivot.rotation.y
      euler.order = 'YZX'
      quat.setFromEuler(euler)
      inputVelocity.applyQuaternion(quat)
      velocity.set(inputVelocity.x, inputVelocity.y, inputVelocity.z)

      body.applyImpulse([velocity.x, velocity.y, velocity.z], [0, 0, 0])
    }

    if (activeAction === 1) {
      mixer.update(delta * distance * 22.5)
    } else {
      mixer.update(delta)
    }

    group.current.position.lerp(worldPosition, 0.3)

    pivot.position.lerp(worldPosition, 0.1)
  })

  return (
    <group ref={outer}>
      <group
        ref={group}
        {...props}
        dispose={null}
        position={[0, 0, 5]}
        rotation={[0, 0, 0]}
        scale={4}
      >
        <group name="Scene">
          <group name="Armature001" rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
            <primitive object={nodes.Hips} />
            <skinnedMesh
              name="Wolf3D_Avatar"
              geometry={nodes.Wolf3D_Avatar.geometry}
              material={materials.Wolf3D_Avatar}
              skeleton={nodes.Wolf3D_Avatar.skeleton}
              morphTargetDictionary={nodes.Wolf3D_Avatar.morphTargetDictionary}
              morphTargetInfluences={nodes.Wolf3D_Avatar.morphTargetInfluences}
            />
          </group>
        </group>
      </group>
    </group>
  )
}

useGLTF.preload('/avatar/male2.glb')
